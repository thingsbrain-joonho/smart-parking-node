// Generated by CoffeeScript 1.8.0
// (function() {
//
//
// }).call(this);

var Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;

ws = require('../../ws');

util = require('util');

events = require('events');

Mpeg1Muxer = require('./mpeg1muxer.js');

STREAM_MAGIC_BYTES = "jsmp";

var serverOpenTime = new Array(20);

VideoStream = function(options) {
  this.name = options.name;
  this.streamUrl = options.streamUrl;
  this.width = options.width;
  this.height = options.height;
  this.wsPort = options.wsPort;
  this.inputStreamStarted = false;
  this.stream = void 0;
  this.startMpeg1Stream();
  this.pipeStreamToSocketServer();
  return this;
};

util.inherits(VideoStream, events.EventEmitter);

VideoStream.prototype.startMpeg1Stream = function() {
  var gettingInputData, gettingOutputData, inputData, outputData, self;
  this.mpeg1Muxer = new Mpeg1Muxer({
    url: this.streamUrl
  });
  self = this;
  if (this.inputStreamStarted) {
    return;
  }
  this.mpeg1Muxer.on('mpeg1data', function(data) {
    return self.emit('camdata', data);
  });
  gettingInputData = false;
  inputData = [];
  gettingOutputData = false;
  outputData = [];
  this.mpeg1Muxer.on('ffmpegError', function(data) {
    var size;
    data = data.toString();
    if (data.indexOf('Input #') !== -1) {
      gettingInputData = true;
    }
    if (data.indexOf('Output #') !== -1) {
      gettingInputData = false;
      gettingOutputData = true;
    }
    if (data.indexOf('frame') === 0) {
      gettingOutputData = false;
    }
    if (gettingInputData) {
      inputData.push(data.toString());
      size = data.match(/\d+x\d+/);
      if (size != null) {
        size = size[0].split('x');
        if (self.width == null) {
          self.width = parseInt(size[0], 10);
        }
        if (self.height == null) {
          return self.height = parseInt(size[1], 10);
        }
      }
    }
  });
  this.mpeg1Muxer.on('ffmpegError', function(data) {
    return global.process.stderr.write(data);
  });
  return this;
};

VideoStream.prototype.pipeStreamToSocketServer = function() {
  var self;
  self = this;
  this.wsServer = new ws.Server({
    port: this.wsPort
  });
  this.wsServer.on("connection", function(socket) {
    // console.log(("Connected WebSocket (") + this.wsServer + " total)");
    return self.onSocketConnect(socket);
  });
  this.wsServer.on("disconnect", function(socket) {
    console.log(("Disconnected WebSocket (") + this.wsServer + " total)");
    return self.onSocketDisconnect(socket);
  });
  this.wsServer.broadcast = function(data, opts) {
    var i, _results;
    _results = [];
    for (i in this.clients) {
      // console.log('client status: ' + this.clients[i].readyState);
      if (this.clients[i].readyState === 1) {
        _results.push(this.clients[i].send(data, opts));
      }
      //else if (this.clients[i].readyState === 2) {
      //   // self.onSocketConnect(socket);
      // }
      else {
        _results.push(console.log("Error: Client (" + i + ") not connected."));
      }
    }
    return _results;
  };
  return this.on('camdata', function(data) {
    return self.wsServer.broadcast(data);
  });
};

VideoStream.prototype.onSocketConnect = function(socket) {
  var self, streamHeader;
  self = this;
  streamHeader = new Buffer(8);
  streamHeader.write(STREAM_MAGIC_BYTES);
  streamHeader.writeUInt16BE(this.width, 4);
  streamHeader.writeUInt16BE(this.height, 6);
  var name = this.name;
  socket.send(streamHeader, {
    binary: true
  });

  console.log(name + " webSocket " + self.wsServer.clients.length + " open");
  return socket.on('close', function(code, message) {
    console.log(name + " webSocket " + self.wsServer.clients.length + " closed");
  });
};

module.exports = VideoStream;
